import psi4
import numpy as np
np.set_printoptions(linewidth=300,precision=5)

basis {
assign s_orb
[ s_orb ]
cartesian
****
H     0
S   1   1.00
      0.50000000000      1.0000000000
S   1   1.00
      0.40000000000      1.0000000000
S   1   1.00
      0.30000000000      1.0000000000
S   1   1.00
      0.20000000000      1.0000000000
****
}

molecule h2o {
symmetry c1
units bohr
0 1
H 0.000000000000 0.000000000000 -0.849220457955
H 0.000000000000 0.000000000000  0.849220457955
}

set scf_type pk
set mp2_type conv
set cc_type conv
set puream false
set maxiter 20
set e_convergence 10
set d_convergence 10
e1, wfn1 = gradient('hf', return_wfn=True)
#e1, wfn1 = gradient('mp2', return_wfn=True)

mol = wfn1.molecule()
bs = wfn1.basisset()
basis = psi4.core.BasisSet.build(mol)
mints = psi4.core.MintsHelper(basis)
C = wfn1.Ca()
s = mints.ao_overlap() 
print(np.asarray(s))
sgrad = mints.ao_oei_deriv1('OVERLAP', 0)
print(np.asarray(sgrad[0]))
print(np.asarray(sgrad[1]))
print(np.asarray(sgrad[2]))
kgrad = mints.ao_oei_deriv1('KINETIC', 0)
print(np.asarray(kgrad[0]))
print(np.asarray(kgrad[1]))
print(np.asarray(kgrad[2]))
#sgrad = mints.mo_oei_deriv1('OVERLAP', 0, C, C)
#print(np.asarray(sgrad[0]))
#print(np.asarray(sgrad[1]))
#print(np.asarray(sgrad[2]))
#print(2.0 * np.einsum("ii->", np.asarray(sgrad[2])[:1,:1]) )

